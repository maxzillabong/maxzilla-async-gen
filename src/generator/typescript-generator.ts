import type { ParsedAsyncAPI, SchemaObject, GeneratorOptions } from '../types/index.js';

export class TypeScriptGenerator {
  private options: GeneratorOptions;
  private generatedTypes = new Set<string>();
  private schemas: Record<string, SchemaObject> = {};
  private pendingInterfaces: string[] = [];

  constructor(options: GeneratorOptions = {}) {
    this.options = {
      enumType: 'union',
      exportEverything: true,
      useUnknown: true,
      ...options,
    };
  }

  generate(parsed: ParsedAsyncAPI): string {
    this.schemas = parsed.schemas;
    this.generatedTypes.clear();
    this.pendingInterfaces = [];

    const parts: string[] = [];

    parts.push(`/**`);
    parts.push(` * Generated from AsyncAPI spec: ${parsed.title} v${parsed.version}`);
    if (parsed.description) {
      parts.push(` * ${parsed.description}`);
    }
    parts.push(` * Generated by maxzilla-async-gen`);
    parts.push(` */\n`);

    parts.push(this.generateSchemas(parsed.schemas));
    parts.push(this.generateMessages(parsed.messages));
    parts.push(this.generateChannelTypes(parsed.channels));

    return parts.filter(Boolean).join('\n\n');
  }

  private generateSchemas(schemas: Record<string, SchemaObject>): string {
    const parts: string[] = [];

    for (const [name, schema] of Object.entries(schemas)) {
      const pascalName = this.toPascalCase(name);
      if (!this.generatedTypes.has(pascalName)) {
        const tsType = this.schemaToTypeScript(pascalName, schema, true);
        if (tsType) {
          parts.push(tsType);
          this.generatedTypes.add(pascalName);
        }

        if (this.pendingInterfaces.length > 0) {
          parts.push(...this.pendingInterfaces);
          this.pendingInterfaces = [];
        }
      }
    }

    return parts.join('\n\n');
  }

  private generateMessages(messages: any[]): string {
    const parts: string[] = [];

    for (const message of messages) {
      const messageName = this.sanitizeIdentifier(this.toPascalCase(message.name));
      const payloadType = this.schemaToTypeScript(`${messageName}Payload`, message.payload, true);

      if (payloadType) {
        parts.push(payloadType);
      }

      if (this.pendingInterfaces.length > 0) {
        parts.push(...this.pendingInterfaces);
        this.pendingInterfaces = [];
      }

      if (message.headers) {
        const headersType = this.schemaToTypeScript(`${messageName}Headers`, message.headers, true);
        if (headersType) {
          parts.push(headersType);
        }

        if (this.pendingInterfaces.length > 0) {
          parts.push(...this.pendingInterfaces);
          this.pendingInterfaces = [];
        }
      }

      const messageInterface = this.generateMessageInterface(messageName, message);
      parts.push(messageInterface);
    }

    return parts.join('\n\n');
  }

  private generateMessageInterface(name: string, message: any): string {
    const parts: string[] = [];

    if (message.description) {
      parts.push(`/**`);
      parts.push(` * ${this.escapeJsDocComment(message.description)}`);
      parts.push(` */`);
    }

    parts.push(`export interface ${name}Message {`);
    parts.push(`  payload: ${name}Payload;`);

    if (message.headers) {
      parts.push(`  headers?: ${name}Headers;`);
    }

    parts.push(`}`);

    return parts.join('\n');
  }

  private generateChannelTypes(channels: any[]): string {
    const parts: string[] = [];

    for (const channel of channels) {
      const channelName = this.sanitizeIdentifier(this.toPascalCase(channel.name));

      if (channel.operations.send?.length > 0) {
        const sendTypes = channel.operations.send
          .map((op: any) => op.messages.map((m: any) => `${this.sanitizeIdentifier(this.toPascalCase(m.name))}Message`))
          .flat();
        if (sendTypes.length > 0) {
          parts.push(`export type ${channelName}SendMessages = ${sendTypes.join(' | ')};`);
        }
      }

      if (channel.operations.receive?.length > 0) {
        const receiveTypes = channel.operations.receive
          .map((op: any) => op.messages.map((m: any) => `${this.sanitizeIdentifier(this.toPascalCase(m.name))}Message`))
          .flat();
        if (receiveTypes.length > 0) {
          parts.push(`export type ${channelName}ReceiveMessages = ${receiveTypes.join(' | ')};`);
        }
      }
    }

    return parts.join('\n\n');
  }

  private schemaToTypeScript(
    name: string,
    schema: SchemaObject,
    isTopLevel = false,
    visited = new Set<string>()
  ): string {
    const safeName = this.sanitizeIdentifier(name);

    if (visited.has(safeName)) {
      return 'any';
    }

    if (this.generatedTypes.has(safeName) && !isTopLevel) {
      return safeName;
    }

    // Handle $ref before adding to visited to avoid false circular detection
    // when property name matches the referenced schema name
    if (schema.$ref) {
      const originalRefName = this.extractRefName(schema.$ref);
      const pascalRefName = this.toPascalCase(originalRefName);

      // Try PascalCase name first, then original name
      const resolvedSchema = this.schemas[pascalRefName] || this.schemas[originalRefName];

      if (!resolvedSchema) {
        console.warn(`Warning: Could not resolve $ref: ${schema.$ref}`);
        return this.options.useUnknown ? 'unknown' : 'any';
      }

      if (!this.generatedTypes.has(pascalRefName)) {
        const resolved = this.schemaToTypeScript(pascalRefName, resolvedSchema, true, new Set(visited));
        if (resolved) {
          this.pendingInterfaces.push(resolved);
          this.generatedTypes.add(pascalRefName);
        }
      }

      // If this is a top-level type (e.g., EventPayload), generate an alias
      if (isTopLevel && safeName !== pascalRefName) {
        return `export type ${safeName} = ${pascalRefName};`;
      }

      return pascalRefName;
    }

    // Add to visited set after $ref handling to avoid false circular detection
    visited.add(safeName);

    if (schema.allOf) {
      const types = schema.allOf.map((s, i) =>
        this.schemaToTypeScript(`${safeName}Part${i}`, s, false, new Set(visited))
      ).join(' & ');
      return isTopLevel ? `export type ${safeName} = ${types};` : `(${types})`;
    }

    if (schema.anyOf) {
      const types = schema.anyOf.map((s, i) =>
        this.schemaToTypeScript(`${safeName}Option${i}`, s, false, new Set(visited))
      ).join(' | ');
      return isTopLevel ? `export type ${safeName} = ${types};` : `(${types})`;
    }

    if (schema.oneOf) {
      const types = schema.oneOf.map((s, i) =>
        this.schemaToTypeScript(`${safeName}Variant${i}`, s, false, new Set(visited))
      ).join(' | ');
      return isTopLevel ? `export type ${safeName} = ${types};` : `(${types})`;
    }

    if (schema.enum) {
      return this.generateEnum(safeName, schema.enum, isTopLevel);
    }

    if (schema.type === 'object' || schema.properties) {
      if (isTopLevel) {
        return this.generateInterface(safeName, schema, true, new Set(visited));
      }

      if (!this.generatedTypes.has(safeName)) {
        const nestedInterface = this.generateInterface(safeName, schema, false, new Set(visited));
        this.pendingInterfaces.push(nestedInterface);
        this.generatedTypes.add(safeName);
      }

      return safeName;
    }

    if (schema.type === 'array' && schema.items) {
      const itemType = this.schemaToTypeScript(`${safeName}Item`, schema.items, false, new Set(visited));
      const arrayType = `${itemType}[]`;
      if (isTopLevel && schema.description) {
        return `/**\n * ${this.escapeJsDocComment(schema.description)}\n */\nexport type ${safeName} = ${arrayType};`;
      }
      return isTopLevel ? `export type ${safeName} = ${arrayType};` : arrayType;
    }

    const primitiveType = this.schemaToPrimitive(schema);
    if (isTopLevel && schema.description) {
      return `/**\n * ${this.escapeJsDocComment(schema.description)}\n */\nexport type ${safeName} = ${primitiveType};`;
    }
    return isTopLevel ? `export type ${safeName} = ${primitiveType};` : primitiveType;
  }

  private generateInterface(
    name: string,
    schema: SchemaObject,
    isTopLevel: boolean,
    visited = new Set<string>()
  ): string {
    const parts: string[] = [];

    if (schema.description && isTopLevel) {
      parts.push(`/**`);
      parts.push(` * ${this.escapeJsDocComment(schema.description)}`);
      parts.push(` */`);
    }

    const exportKeyword = isTopLevel ? 'export ' : '';
    parts.push(`${exportKeyword}interface ${name} {`);

    if (schema.properties) {
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        const isRequired = schema.required?.includes(propName);
        const optional = isRequired ? '' : '?';

        if (propSchema.description) {
          parts.push(`  /** ${this.escapeJsDocComment(propSchema.description)} */`);
        }

        let propType: string;
        if (propSchema.type === 'object' || propSchema.properties) {
          const nestedName = this.sanitizeIdentifier(`${name}${this.toPascalCase(propName)}`);

          if (!visited.has(nestedName) && !this.generatedTypes.has(nestedName)) {
            const nestedInterface = this.generateInterface(nestedName, propSchema, false, new Set(visited));
            this.pendingInterfaces.push(nestedInterface);
            this.generatedTypes.add(nestedName);
          }

          propType = nestedName;
        } else {
          propType = this.schemaToTypeScript(
            this.toPascalCase(propName),
            propSchema,
            false,
            new Set(visited)
          );
        }

        // Quote property name if it's not a valid identifier or contains special characters
        const needsQuoting = !this.isValidIdentifier(propName);
        const quotedProp = needsQuoting ? `'${propName.replace(/'/g, "\\'")}'` : propName;
        parts.push(`  ${quotedProp}${optional}: ${propType};`);
      }
    }

    if (schema.additionalProperties) {
      const additionalType =
        typeof schema.additionalProperties === 'boolean'
          ? 'any'
          : this.schemaToTypeScript('AdditionalProperty', schema.additionalProperties, false, new Set(visited));
      parts.push(`  [key: string]: ${additionalType};`);
    }

    parts.push(`}`);

    return parts.join('\n');
  }

  private generateEnum(name: string, values: string[], isTopLevel: boolean): string {
    if (this.options.enumType === 'enum') {
      // When nested (not top-level), generate the enum separately and return just the name
      if (!isTopLevel) {
        // Only generate if not already generated
        if (!this.generatedTypes.has(name)) {
          const parts: string[] = [];
          parts.push(`export enum ${name} {`);
          for (const value of values) {
            const enumKey = this.toEnumKey(value);
            parts.push(`  ${enumKey} = '${value}',`);
          }
          parts.push(`}`);
          this.pendingInterfaces.push(parts.join('\n'));
          this.generatedTypes.add(name);
        }
        return name;
      }

      // Top-level enum
      const parts: string[] = [];
      parts.push(`export enum ${name} {`);
      for (const value of values) {
        const enumKey = this.toEnumKey(value);
        parts.push(`  ${enumKey} = '${value}',`);
      }
      parts.push(`}`);
      return parts.join('\n');
    } else {
      const unionType = values.map(v => `'${this.escapeStringLiteral(v)}'`).join(' | ');
      return isTopLevel ? `export type ${name} = ${unionType};` : unionType;
    }
  }

  private schemaToPrimitive(schema: SchemaObject): string {
    if (!schema.type) {
      return this.options.useUnknown ? 'unknown' : 'any';
    }

    switch (schema.type) {
      case 'string':
        return 'string';
      case 'number':
      case 'integer':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'null':
        return 'null';
      default:
        return this.options.useUnknown ? 'unknown' : 'any';
    }
  }

  private extractRefName(ref: string): string {
    const parts = ref.split('/');
    return parts[parts.length - 1]; // Return original name without PascalCase conversion
  }

  private sanitizeIdentifier(name: string): string {
    let sanitized = name.replace(/[^a-zA-Z0-9_$]/g, '_');

    if (/^\d/.test(sanitized)) {
      sanitized = '_' + sanitized;
    }

    const reserved = [
      'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default',
      'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally',
      'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'null',
      'return', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof',
      'var', 'void', 'while', 'with', 'let', 'static', 'yield', 'await',
      'interface', 'type', 'implements', 'package', 'private', 'protected', 'public'
    ];

    if (reserved.includes(sanitized.toLowerCase())) {
      sanitized = sanitized + '_';
    }

    return sanitized;
  }

  private isValidIdentifier(name: string): boolean {
    // Check if name is a valid JavaScript/TypeScript identifier
    if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
      return false;
    }

    // Check if it's a reserved word
    const reserved = [
      'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default',
      'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally',
      'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'null',
      'return', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof',
      'var', 'void', 'while', 'with', 'let', 'static', 'yield', 'await',
      'interface', 'type', 'implements', 'package', 'private', 'protected', 'public'
    ];

    return !reserved.includes(name.toLowerCase());
  }

  private escapeJsDocComment(text: string): string {
    return text.replace(/\*\//g, '*\\/').replace(/\n/g, ' ');
  }

  private escapeStringLiteral(text: string): string {
    return text.replace(/'/g, "\\'");
  }

  private toPascalCase(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
      .replace(/^[a-z]/, chr => chr.toUpperCase());
  }

  private toEnumKey(value: string): string {
    let key = value.toUpperCase().replace(/[^A-Z0-9]+/g, '_');

    if (/^\d/.test(key)) {
      key = '_' + key;
    }

    return key;
  }
}
